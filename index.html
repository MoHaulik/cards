<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>AR Trading Card Battle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
    #overlay {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      color: white; text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }
    #start-button {
      pointer-events: auto;
      padding: 15px 30px; font-size: 18px;
      background-color: #4CAF50; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    #game-ui {
      position: absolute; bottom: 20px; left: 0; right: 0;
      display: flex; justify-content: center;
      z-index: 10; pointer-events: none;
    }
    .button {
      background-color: rgba(0,0,0,0.7);
      color: white; border: 2px solid #4CAF50;
      padding: 10px 15px; border-radius: 5px;
      margin: 0 10px; cursor: pointer;
      pointer-events: auto; font-size: 16px;
      transition: opacity 0.2s;
    }
    #game-info {
      position: absolute; top: 10px; right: 10px;
      background-color: rgba(0,0,0,0.6);
      color: white; padding: 10px; border-radius: 5px;
      font-size: 14px; z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Start AR Battle</button>
  </div>
  <div id="game-ui" style="display:none;">
    <button class="button" id="attack-button">Attack</button>
    <button class="button" id="special-button">Special Move</button>
    <button class="button" id="end-turn-button">End Turn</button>
  </div>
  <div id="game-info" style="display:none;">
    <div>Player HP: <span id="player-hp">100</span></div>
    <div>Enemy HP: <span id="enemy-hp">100</span></div>
    <div>Turn: <span id="turn-counter">1</span></div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';

    let camera, scene, renderer;
    let clock = new THREE.Clock();
    let reticle;
    let hitTestSource = null, viewerSpace = null;
    let localReferenceSpace = null;
    let playerCard, enemyCard;
    let playerCardData, enemyCardData;
    let playerHP = 100, enemyHP = 100;
    let currentTurn = 1, isPlayerTurn = true, attackInProgress = false;
    let gameStarted = false;
    let playerCardPosition = new THREE.Vector3(), enemyCardPosition = new THREE.Vector3();

    const cardTypes = [
      { name: "Flameon", type: "Fire", attack: 15, defense: 5, special: "Flame Burst", specialDamage: 25, color: 0xff5500, particleColor: 0xff3300 },
      { name: "Aquara", type: "Water", attack: 12, defense: 8, special: "Tidal Wave", specialDamage: 22, color: 0x0066ff, particleColor: 0x00ccff },
      { name: "Leafix", type: "Grass", attack: 10, defense: 10, special: "Vine Whip", specialDamage: 20, color: 0x33cc33, particleColor: 0x99ff66 },
      { name: "Zapdos", type: "Electric", attack: 18, defense: 3, special: "Thunder Strike", specialDamage: 30, color: 0xffcc00, particleColor: 0xffff00 }
    ];

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lighting
      scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(0,5,5);
      scene.add(dirLight);

      // Reticle for placement
      const ring = new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI/2);
      const mat = new THREE.MeshBasicMaterial({ color: 0x0fff00 });
      reticle = new THREE.Mesh(ring, mat);
      reticle.visible = false;
      scene.add(reticle);

      // UI listeners
      document.getElementById('start-button').addEventListener('click', startARSession);
      document.getElementById('attack-button').addEventListener('click', performAttack);
      document.getElementById('special-button').addEventListener('click', performSpecialAttack);
      document.getElementById('end-turn-button').addEventListener('click', endTurn);
      window.addEventListener('resize', onWindowResize);
    }

    function startARSession() {
      if (!navigator.xr) return alert('WebXR not supported');
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if (!supported) return alert('AR not supported');
        navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        }).then(onSessionStarted);
      });
    }

    function onSessionStarted(session) {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      localReferenceSpace = renderer.xr.getReferenceSpace();

      // Set up hit-test source
      session.requestReferenceSpace('viewer').then((ref) => {
        viewerSpace = ref;
        session.requestHitTestSource({ space: viewerSpace }).then((source) => {
          hitTestSource = source;
        });
      });

      session.addEventListener('select', onSelect);
      session.addEventListener('end', () => {
        hitTestSource = null;
        gameStarted = false;
        document.getElementById('overlay').style.display = '';
        document.getElementById('start-button').style.display = '';
        document.getElementById('game-ui').style.display = 'none';
        document.getElementById('game-info').style.display = 'none';
        renderer.setAnimationLoop(null);
      });

      // Update UI
      document.getElementById('start-button').style.display = 'none';
      document.getElementById('overlay').innerHTML = '<div>Tap the screen to place cards</div>';
      renderer.setAnimationLoop(render);
    }

    function onSelect() {
      if (reticle.visible && !gameStarted) {
        // Define card positions based on reticle
        playerCardPosition.copy(reticle.position).add(new THREE.Vector3(-0.1, 0, 0));
        enemyCardPosition.copy(reticle.position).add(new THREE.Vector3(0.1, 0, 0));

        initGame();
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('game-ui').style.display = 'flex';
        document.getElementById('game-info').style.display = 'block';
        gameStarted = true;
      }
    }

    function initGame() {
      // Random card selection
      playerCardData = cardTypes[Math.floor(Math.random() * cardTypes.length)];
      do {
        enemyCardData = cardTypes[Math.floor(Math.random() * cardTypes.length)];
      } while (enemyCardData.name === playerCardData.name);

      playerHP = 100;
      enemyHP = 100;
      currentTurn = 1;
      isPlayerTurn = true;
      attackInProgress = false;
      updateGameInfo();

      createCards();
      createAttackParticles();
    }

    function createCards() {
      if (playerCard) scene.remove(playerCard);
      if (enemyCard) scene.remove(enemyCard);
      playerCard = createCard(playerCardData, playerCardPosition, true);
      enemyCard = createCard(enemyCardData, enemyCardPosition, false);
    }

    function createCard(data, position, isPlayer) {
      const card = new THREE.Group();
      // Base
      const geo = new THREE.BoxGeometry(0.2, 0.3, 0.01);
      const mat = new THREE.MeshPhongMaterial({ color: data.color, transparent: true, opacity: 0.9 });
      const mesh = new THREE.Mesh(geo, mat);
      card.add(mesh);
      // Border
      const border = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.32, 0.005), new THREE.MeshPhongMaterial({ color: 0xffd700, transparent: true, opacity: 0.7 }));
      border.position.z = -0.01;
      card.add(border);
      // Character sphere
      const charMesh = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: data.color, emissiveIntensity: 0.5 }));
      charMesh.position.z = 0.03;
      card.add(charMesh);
      // Text labels
      function makeLabel(text, fontSize, yOffset) {
        const cv = document.createElement('canvas'); cv.width = 256; cv.height = 64;
        const ctx = cv.getContext('2d'); ctx.fillStyle = '#fff'; ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center'; ctx.fillText(text, 128, 40);
        const tx = new THREE.CanvasTexture(cv);
        const pl = new THREE.PlaneGeometry(0.15, fontSize/256 * 0.04);
        const ml = new THREE.MeshBasicMaterial({ map: tx, transparent: true });
        const mesh = new THREE.Mesh(pl, ml);
        mesh.position.set(0, yOffset, 0.02);
        return mesh;
      }
      card.add(makeLabel(data.name, 32, 0.12));
      card.add(makeLabel(`${data.type} | ATK: ${data.attack}`, 24, -0.12));

      card.position.copy(position);
      if (isPlayer) card.rotation.y = Math.PI;
      card.userData = data;
      scene.add(card);
      return card;
    }

    function createAttackParticles() {
      if (scene.getObjectByName('p1')) scene.remove(scene.getObjectByName('p1'));
      if (scene.getObjectByName('p2')) scene.remove(scene.getObjectByName('p2'));

      playerAttackParticles = makeParticleSystem(playerCardData.particleColor, 'p1');
      enemyAttackParticles = makeParticleSystem(enemyCardData.particleColor, 'p2');
      scene.add(playerAttackParticles, enemyAttackParticles);
    }

    function makeParticleSystem(colorHex, name) {
      const geom = new THREE.BufferGeometry();
      const count = 100;
      const pos = new Float32Array(count*3);
      const cols = new Float32Array(count*3);
      const sz = new Float32Array(count);
      const c = new THREE.Color(colorHex);
      for (let i=0; i<count; i++) {
        pos.set([0,0,0], i*3);
        cols.set([c.r, c.g, c.b], i*3);
        sz[i] = Math.random()*0.02 + 0.01;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geom.setAttribute('color', new THREE.BufferAttribute(cols,3));
      geom.setAttribute('size', new THREE.BufferAttribute(sz,1));
      const mat = new THREE.ShaderMaterial({
        uniforms: { pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png') } },
        vertexShader: `attribute float size; varying vec3 vColor; void main(){ vColor=color; vec4 mv=modelViewMatrix*vec4(position,1.0); gl_PointSize=size*(300.0/-mv.z); gl_Position=projectionMatrix*mv; }`,
        fragmentShader: `uniform sampler2D pointTexture; varying vec3 vColor; void main(){ gl_FragColor=vec4(vColor,1.0)*texture2D(pointTexture,gl_PointCoord); if(gl_FragColor.a<0.3) discard; }`,
        blending: THREE.AdditiveBlending, depthTest: true, transparent: true, vertexColors: true
      });
      const pts = new THREE.Points(geom, mat);
      pts.name = name;
      pts.visible = false;
      return pts;
    }

    function performAttack() { /* same as before, using card data & particles */ }
    function performSpecialAttack() { /* same as before */ }
    function animateAttack(card, particles, start, end, onDone) { /* same as before */ }
    function enemyAttack() { /* same as before */ }
    function endTurn() { if (!isPlayerTurn||attackInProgress) return; isPlayerTurn=false; updateGameInfo(); setTimeout(enemyAttack, 1000); }
    function endEnemyTurn() { isPlayerTurn=true; currentTurn++; updateGameInfo(); }
    function calculateDamage(atk, def) { const m=0.8+Math.random()*0.4; return Math.max(1, Math.floor((atk-def/2)*m)); }

    function updateGameInfo() {
      document.getElementById('player-hp').textContent = playerHP;
      document.getElementById('enemy-hp').textContent = enemyHP;
      document.getElementById('turn-counter').textContent = currentTurn;
      ['attack-button','special-button','end-turn-button'].forEach(id => {
        const btn = document.getElementById(id);
        btn.disabled = !isPlayerTurn || attackInProgress;
        btn.style.opacity = btn.disabled ? '0.5' : '1';
      });
    }

    function gameOver(win) { /* same as before */ }
    function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

    function render(time, frame) {
      if (frame) {
        const ref = localReferenceSpace;
        if (hitTestSource && !gameStarted) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length) {
            const pose = hits[0].getPose(ref);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
            reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
          } else reticle.visible = false;
        }
      }
      if (gameStarted) {
        const t = clock.getElapsedTime();
        if (playerCard) {
          playerCard.position.y = playerCardPosition.y + Math.sin(t*2)*0.02;
          playerCard.rotation.y = Math.PI + Math.sin(t)*0.1;
        }
        if (enemyCard) {
          enemyCard.position.y = enemyCardPosition.y + Math.sin(t*2+Math.PI)*0.02;
          enemyCard.rotation.y = Math.sin(t)*0.1;
        }
      }
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
