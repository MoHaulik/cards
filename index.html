<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Floating AR Card Battle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
    #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; text-align: center; }
    #start-button { padding: 15px 30px; font-size: 18px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: all 0.2s; }
    #start-button:hover { background-color: #45a049; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
    #start-button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    #game-ui { position: absolute; bottom: 20px; left: 0; right: 0; display: flex; justify-content: center; z-index: 10; pointer-events: none; }
    .button { background-color: rgba(0,0,0,0.7); color: white; border: 2px solid #4CAF50; padding: 10px 15px; border-radius: 5px; margin: 0 10px; cursor: pointer; pointer-events: auto; font-size: 16px; transition: all 0.2s; }
    .button:hover:not([disabled]) { background-color: rgba(0,0,0,0.9); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
    .button:active:not([disabled]) { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    .button[disabled] { opacity: 0.5; cursor: not-allowed; }
    #game-info { position: absolute; top: 10px; right: 10px; background-color: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 5px; font-size: 14px; z-index: 10; pointer-events: none; }
    #battle-log { position: absolute; top: 100px; right: 10px; width: 200px; background-color: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 5px; font-size: 14px; z-index: 10; pointer-events: none; max-height: 150px; overflow-y: auto; }
    #battle-log p { margin: 5px 0; }
    #tutorial { position: absolute; bottom: 80px; left: 0; right: 0; background-color: rgba(0,0,0,0.7); color: white; padding: 15px; font-size: 16px; text-align: center; transition: opacity 0.5s; }
    .hp-bar { height: 6px; background-color: #4CAF50; margin-top: 3px; transition: width 0.5s; }
    .type-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; margin-right: 5px; vertical-align: middle; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    .pulse { animation: pulse 1.5s infinite; }
    #card-deck { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; justify-content: center; z-index: 11; pointer-events: none; display: none; }
    .deck-preview { width: 60px; height: 90px; background: rgba(0,0,0,0.5); border: 2px solid gold; border-radius: 5px; margin: 0 5px; pointer-events: auto; cursor: pointer; transition: transform 0.2s; overflow: hidden; }
    .deck-preview:hover { transform: translateY(-5px); }
    .deck-preview.selected { box-shadow: 0 0 10px #fff, 0 0 20px gold; }
    .deck-preview-color { width: 100%; height: 30%; }
    .deck-preview-name { color: white; font-size: 10px; text-align: center; padding: 2px; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1 style="color:white; text-shadow:0 0 10px #4CAF50;">Floating Card Battle</h1>
    <button id="start-button">Start AR Experience</button>
  </div>
  <div id="game-ui" style="display:none;">
    <button class="button" id="attack-button" disabled>Attack</button>
    <button class="button" id="special-button" disabled>Special Move</button>
    <button class="button" id="rotate-view">Rotate View</button>
  </div>
  <div id="card-deck" style="display:none;"></div>
  <div id="game-info" style="display:none;">
    <div>Player: <span id="player-name">Select Card</span> <span id="player-type-icon" class="type-icon"></span></div>
    <div>HP: <span id="player-hp">100</span>/100 <div class="hp-bar" id="player-hp-bar" style="width: 100%"></div></div>
    <div style="margin-top: 10px;">Enemy: <span id="enemy-name">Card</span> <span id="enemy-type-icon" class="type-icon"></span></div>
    <div>HP: <span id="enemy-hp">100</span>/100 <div class="hp-bar" id="enemy-hp-bar" style="width: 100%"></div></div>
    <div style="margin-top: 10px;">Turn: <span id="turn-counter">1</span> (<span id="turn-indicator">Select Card</span>)</div>
  </div>
  <div id="battle-log" style="display:none;"></div>
  <div id="tutorial" style="display:none;">
    Select your card by reaching out and tapping it.<br>
    Cards will float in front of youâ€”tap a card to select.<br>
    Touch anywhere in AR to dismiss this message.
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js';
    import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js';

    let camera, scene, renderer, controller;
    let clock = new THREE.Clock();
    let cards = [], selectedCard = null, enemyCard = null;
    let playerCardData, enemyCardData;
    let playerHP = 100, enemyHP = 100;
    let currentTurn = 1, isPlayerTurn = true, gamePhase = 'selection';
    let playerAttackParticles, enemyAttackParticles;
    let battleArena, xrSessionActive = false;
    let font, damageTexts = [];
    let raycaster = new THREE.Raycaster();
    let rotationSpeed = 0;

    const playerPosition = new THREE.Vector3(0, 0, -0.6);
    const enemyPosition  = new THREE.Vector3(0, 0.4, -0.6);
    const deckPositions = [
      new THREE.Vector3(-0.3, -0.2, -0.7),
      new THREE.Vector3(-0.1, -0.2, -0.7),
      new THREE.Vector3( 0.1, -0.2, -0.7),
      new THREE.Vector3( 0.3, -0.2, -0.7)
    ];

    const typeEffectiveness = {
      Fire:     { Water: 0.5, Grass: 2.0, Fire: 1.0, Electric: 1.0 },
      Water:    { Fire: 2.0, Grass: 0.5, Water: 1.0, Electric: 0.5 },
      Grass:    { Fire: 0.5, Water: 2.0, Grass: 1.0, Electric: 1.0 },
      Electric: { Water: 2.0, Grass: 0.5, Fire: 1.0, Electric: 1.0 }
    };

    const cardTypes = [
      { name: 'Flameon', type: 'Fire',     attack: 15, defense: 5,  special: 'Flame Burst',    specialDamage: 25, color: 0xff5500, particleColor: 0xff3300 },
      { name: 'Aquara',  type: 'Water',    attack: 12, defense: 8,  special: 'Tidal Wave',     specialDamage: 22, color: 0x0066ff, particleColor: 0x00ccff },
      { name: 'Leafix',  type: 'Grass',    attack: 10, defense: 10, special: 'Vine Whip',      specialDamage: 20, color: 0x33cc33, particleColor: 0x99ff66 },
      { name: 'Zapdos',  type: 'Electric', attack: 18, defense: 3,  special: 'Thunder Strike', specialDamage: 30, color: 0xffcc00, particleColor: 0xffff00 }
    ];

    new FontLoader().load(
      'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json',
      f => font = f
    );

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false, logarithmicDepthBuffer: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(0, 5, 5);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.set(1024, 1024);
      scene.add(dirLight);

      // Battle arena
      battleArena = createBattleArena();
      scene.add(battleArena);

      // UI handlers
      document.getElementById('start-button').addEventListener('click', startARSession);
      document.getElementById('attack-button').addEventListener('click', performAttack);
      document.getElementById('special-button').addEventListener('click', performSpecialAttack);
      document.getElementById('rotate-view').addEventListener('click', toggleRotation);
      document.getElementById('tutorial').addEventListener('click', () => {
        document.getElementById('tutorial').style.display = 'none';
      });

      createDeckPreview();
      window.addEventListener('resize', onWindowResize);
    }

    function createDeckPreview() {
      const deckEl = document.getElementById('card-deck');
      cardTypes.forEach((card, idx) => {
        const preview = document.createElement('div');
        preview.className = 'deck-preview';
        preview.dataset.index = idx;
        preview.innerHTML = `
          <div class="deck-preview-color" style="background-color:#${card.color.toString(16).padStart(6,'0')}"></div>
          <div class="deck-preview-name">${card.name}</div>`;
        preview.addEventListener('click', () => selectDeckCard(idx));
        deckEl.appendChild(preview);
      });
    }

    function selectDeckCard(idx) {
      document.querySelectorAll('.deck-preview').forEach(el => el.classList.remove('selected'));
      const el = document.querySelector(`.deck-preview[data-index="${idx}"]`);
      el.classList.add('selected');

      playerCardData = cardTypes[idx];
      document.getElementById('player-name').textContent = playerCardData.name;
      document.getElementById('player-type-icon').style.backgroundColor = `#${playerCardData.color.toString(16).padStart(6,'0')}`;

      if (selectedCard) scene.remove(selectedCard);
      selectedCard = createCard(playerCardData, playerPosition, true);
      scene.add(selectedCard);

      if (!enemyCard) {
        do { enemyCardData = cardTypes[Math.floor(Math.random()*cardTypes.length)]; }
        while (enemyCardData.name === playerCardData.name);
        enemyCard = createCard(enemyCardData, enemyPosition, false);
        scene.add(enemyCard);
        document.getElementById('enemy-name').textContent = enemyCardData.name;
        document.getElementById('enemy-type-icon').style.backgroundColor = `#${enemyCardData.color.toString(16).padStart(6,'0')}`;
      }

      // remove floating deck
      cards.forEach(c => scene.remove(c));
      cards = [];
      startBattle();
    }

    function toggleRotation() {
      rotationSpeed = rotationSpeed ? 0 : 0.5;
      document.getElementById('rotate-view').textContent = rotationSpeed ? 'Stop Rotation' : 'Rotate View';
    }

    function createBattleArena() {
      const grp = new THREE.Group();
      const plat = new THREE.Mesh(
        new THREE.CylinderGeometry(0.6,0.65,0.02,32),
        new THREE.MeshPhongMaterial({ color:0x111133, transparent:true, opacity:0.7, shininess:90, emissive:0x0033ff, emissiveIntensity:0.2 })
      );
      plat.receiveShadow = true;
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.6,0.01,16,64),
        new THREE.MeshBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.8 })
      );
      ring.rotation.x = Math.PI/2; ring.position.y = 0.01;
      const core = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05,0.05,0.6,16),
        new THREE.MeshBasicMaterial({ color:0x88ccff, transparent:true, opacity:0.7 })
      );
      core.position.y = 0.3;

      // ambient particles
      const pCount = 200;
      const pGeo = new THREE.BufferGeometry();
      const pPos = new Float32Array(pCount*3);
      const pVel = [];
      for (let i=0;i<pCount;i++){
        const r = 0.6*Math.random();
        const th = Math.random()*Math.PI*2;
        pPos[i*3]=r*Math.cos(th);
        pPos[i*3+1]=Math.random()*0.8;
        pPos[i*3+2]=r*Math.sin(th);
        pVel.push({y:0.005+Math.random()*0.01, rot:Math.random()*0.01});
      }
      pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
      const pMat = new THREE.PointsMaterial({ color:0x88ccff, size:0.01, transparent:true, opacity:0.6, sizeAttenuation:true });
      const particles = new THREE.Points(pGeo,pMat);
      particles.userData = { velocities: pVel };
      grp.add(plat, ring, core, particles);
      grp.userData.particles = particles;
      grp.position.set(0,-0.3,-1.0);
      return grp;
    }

    function createCard(data, pos, isPlayer) {
      const grp = new THREE.Group();
      // base
      const base = new THREE.Mesh(
        new THREE.BoxGeometry(0.2,0.3,0.01),
        new THREE.MeshPhongMaterial({ color:data.color, transparent:true, opacity:0.9, shininess:90 })
      );
      base.castShadow = base.receiveShadow = true;
      // border
      const border = new THREE.Mesh(
        new THREE.BoxGeometry(0.22,0.32,0.005),
        new THREE.MeshPhongMaterial({ color:0xffd700, transparent:true, opacity:0.9, emissive:0xffd700, emissiveIntensity:0.4 })
      );
      border.position.z = -0.01; border.castShadow = true;
      // character sphere
      const char = new THREE.Mesh(
        new THREE.SphereGeometry(0.05,32,32),
        new THREE.MeshPhongMaterial({ color:0xffffff, emissive:data.color, emissiveIntensity:0.6, shininess:100 })
      );
      char.position.z = 0.03; char.castShadow = true;
      // aura & energy
      const glow = new THREE.Mesh(
        new THREE.SphereGeometry(0.06,32,32),
        new THREE.MeshBasicMaterial({ color:data.color, transparent:true, opacity:0.4, side:THREE.BackSide })
      );
      glow.position.copy(char.position);
      const eGeo = new THREE.BufferGeometry();
      const eCount = 50;
      const ePos = new Float32Array(eCount*3);
      for (let i=0;i<eCount;i++){
        ePos[i*3]   = (Math.random()-0.5)*0.05;
        ePos[i*3+1] = (Math.random()-0.5)*0.05;
        ePos[i*3+2] = (Math.random()-0.5)*0.05;
      }
      eGeo.setAttribute('position', new THREE.BufferAttribute(ePos,3));
      const energy = new THREE.Points(
        eGeo,
        new THREE.PointsMaterial({ color:data.color, size:0.005, transparent:true, opacity:0.7, sizeAttenuation:true })
      );
      energy.position.copy(char.position);

      addCardLabels(grp, data);

      grp.add(base, border, char, glow, energy);
      grp.position.copy(pos);
      grp.userData = { ...data, energy, float: {
        startY: pos.y,
        speed: isPlayer?2:2.2,
        phase: isPlayer?0:Math.PI,
        rotSpeed: isPlayer?0.1:0.2
      }};
      base.userData = { isCard:true, parentGroup:grp };
      return grp;
    }

    function addCardLabels(group, data) {
      function txtCanvas(text, fontSize, w,h) {
        const c = document.createElement('canvas');
        c.width=w; c.height=h;
        const ctx=c.getContext('2d');
        ctx.fillStyle='rgba(0,0,0,0.7)';
        ctx.beginPath(); ctx.roundRect(0,0,w,h,8); ctx.fill();
        ctx.fillStyle='#fff';
        ctx.font=`bold ${fontSize}px Arial`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(text,w/2,h/2);
        return new THREE.CanvasTexture(c);
      }
      const nameMat = new THREE.MeshBasicMaterial({ map: txtCanvas(data.name,24,256,64), transparent:true });
      const nameMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.15,0.04), nameMat);
      nameMesh.position.set(0,0.12,0.02);
      const stats = `${data.type} | ATK:${data.attack} | DEF:${data.defense}`;
      const statsMat = new THREE.MeshBasicMaterial({ map: txtCanvas(stats,18,256,48), transparent:true });
      const statsMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.15,0.03), statsMat);
      statsMesh.position.set(0,-0.12,0.02);
      const specMat = new THREE.MeshBasicMaterial({ map: txtCanvas(data.special,16,256,40), transparent:true });
      const specMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.12,0.025), specMat);
      specMesh.position.set(0,-0.08,0.02);

      group.add(nameMesh, statsMesh, specMesh);
    }

    function createFloatingDeck() {
      // remove old
      cards.forEach(c=>scene.remove(c));
      cards = [];
      cardTypes.forEach((cData,i)=>{
        const c3 = createCard(cData, deckPositions[i], true);
        scene.add(c3);
        cards.push(c3);
      });
    }

    function onSelect() {
      if (gamePhase !== 'selection') return;
      // raycast from controller
      const tempMat = new THREE.Matrix4().identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMat);
      const hits = raycaster.intersectObjects(scene.children, true);
      for (let h of hits) {
        const obj = h.object;
        if (obj.userData.isCard) {
          const grp = obj.userData.parentGroup;
          const idx = cardTypes.findIndex(cd=>cd.name===grp.userData.name);
          selectDeckCard(idx);
          break;
        }
      }
    }

    function startBattle() {
      gamePhase = 'battle';
      isPlayerTurn = true;
      currentTurn = 1;
      playerHP = enemyHP = 100;
      updateHPBars();
      document.getElementById('turn-indicator').textContent = 'Player';
      document.getElementById('turn-counter').textContent = currentTurn;
      document.getElementById('attack-button').disabled = false;
      document.getElementById('special-button').disabled = false;
      logBattle('Battle start! Player\'s turn.');
    }

    function performAttack() { if (!isPlayerTurn) return; doAttack(false); }
    function performSpecialAttack() { if (!isPlayerTurn) return; doAttack(true); }

    function doAttack(isSpecial) {
      const attacker = isPlayerTurn ? playerCardData : enemyCardData;
      const defender = isPlayerTurn ? enemyCardData  : playerCardData;
      const base = isSpecial ? attacker.specialDamage : attacker.attack;
      const mult = typeEffectiveness[attacker.type][defender.type] || 1;
      const dmg = Math.round(base * mult);
      if (isPlayerTurn) enemyHP = Math.max(0, enemyHP - dmg);
      else            playerHP = Math.max(0, playerHP - dmg);
      updateHPBars();
      logBattle(`${isPlayerTurn?'Player':'Enemy'} used ${isSpecial?attacker.special: 'Attack'} for ${dmg} damage!`);
      showDamageText(isPlayerTurn?enemyPosition:playerPosition, dmg);
      createAttackParticles();
      launchParticles(isPlayerTurn);
    }

    function createAttackParticles() {
      if (playerAttackParticles) scene.remove(playerAttackParticles);
      if (enemyAttackParticles)  scene.remove(enemyAttackParticles);
      playerAttackParticles = makeParticles(playerCardData.particleColor, 'p1');
      enemyAttackParticles  = makeParticles(enemyCardData.particleColor,  'p2');
      scene.add(playerAttackParticles, enemyAttackParticles);
    }

    function makeParticles(colorHex, name) {
      const cnt=150;
      const geo=new THREE.BufferGeometry();
      const pos=new Float32Array(cnt*3), col=new Float32Array(cnt*3), sz=new Float32Array(cnt);
      const c=new THREE.Color(colorHex);
      for(let i=0;i<cnt;i++){
        pos[i*3]=pos[i*3+1]=pos[i*3+2]=0;
        col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
        sz[i]=0.01+Math.random()*0.02;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.setAttribute('color',    new THREE.BufferAttribute(col,3));
      geo.setAttribute('size',     new THREE.BufferAttribute(sz,1));

      const mat=new THREE.ShaderMaterial({
        uniforms:{ time:{value:0}, pointTexture:{value:new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png')} },
        vertexShader:`
          attribute float size; attribute vec3 color; varying vec3 vColor;
          void main(){
            vColor=color;
            vec4 mvPos=modelViewMatrix*vec4(position,1.);
            gl_PointSize=size*(300./-mvPos.z);
            gl_Position=projectionMatrix*mvPos;
          }`,
        fragmentShader:`
          uniform sampler2D pointTexture; varying vec3 vColor;
          void main(){
            gl_FragColor=vec4(vColor,1.)*texture2D(pointTexture,gl_PointCoord);
          }`,
        transparent:true, vertexColors:true, name
      });

      const pts=new THREE.Points(geo,mat);
      pts.name=name;
      pts.visible=false;
      pts.userData={ start:0, anim:false, vel:new THREE.Vector3(), dur:0.6 };
      return pts;
    }

    function launchParticles(fromPlayer) {
      const now = clock.getElapsedTime();
      const pSys = fromPlayer ? playerAttackParticles : enemyAttackParticles;
      const fromPos = fromPlayer?playerPosition:enemyPosition;
      const toPos   = fromPlayer?enemyPosition:playerPosition;
      pSys.position.copy(fromPos);
      const vel = new THREE.Vector3().subVectors(toPos,fromPos).divideScalar(pSys.userData.dur);
      pSys.userData.vel.copy(vel);
      pSys.userData.start = now;
      pSys.userData.anim = true;
      pSys.visible = true;
    }

    function showDamageText(pos, dmg) {
      if (!font) return;
      const geo=new TextGeometry(`-${dmg}`, { font,fontSize:0.05, height:0.001 });
      const mat=new THREE.MeshBasicMaterial({ color:0xff4444, transparent:true });
      const txt=new THREE.Mesh(geo,mat);
      txt.position.copy(pos).add(new THREE.Vector3(0,0.1,0));
      scene.add(txt);
      damageTexts.push({ mesh:txt, start: clock.getElapsedTime(), dur:1.0 });
    }

    function updateHPBars() {
      const pPct = (playerHP/100)*100;
      const ePct = (enemyHP /100)*100;
      document.getElementById('player-hp').textContent = playerHP;
      document.getElementById('player-hp-bar').style.width = `${pPct}%`;
      document.getElementById('enemy-hp').textContent  = enemyHP;
      document.getElementById('enemy-hp-bar').style.width  = `${ePct}%`;
    }

    function logBattle(msg) {
      const p = document.createElement('p');
      p.textContent = msg;
      document.getElementById('battle-log').appendChild(p);
      document.getElementById('battle-log').scrollTop = 1e9;
    }

    function nextTurn() {
      if (playerHP===0 || enemyHP===0) {
        const res = playerHP===0 ? 'You Lose!' : 'You Win!';
        logBattle(res);
        document.getElementById('attack-button').disabled = true;
        document.getElementById('special-button').disabled = true;
        return;
      }
      isPlayerTurn = !isPlayerTurn;
      if (isPlayerTurn) {
        currentTurn++;
        document.getElementById('turn-counter').textContent = currentTurn;
      }
      document.getElementById('turn-indicator').textContent = isPlayerTurn?'Player':'Enemy';
      if (!isPlayerTurn) {
        setTimeout(()=> {
          // simple AI: choose special if it'll KO, else attack
          const cd = enemyCardData;
          const def = playerCardData;
          const d1 = Math.round(cd.attack * (typeEffectiveness[cd.type][def.type]||1));
          const d2 = Math.round(cd.specialDamage * (typeEffectiveness[cd.type][def.type]||1));
          doAttack((playerHP <= d2) ? true : false);
        }, 800);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }

    function animateParticles(sys, delta) {
      if (!sys.userData.anim) return;
      const t = clock.getElapsedTime() - sys.userData.start;
      if (t > sys.userData.dur) {
        sys.visible = false;
        sys.userData.anim = false;
        nextTurn();
        return;
      }
      sys.position.addScaledVector(sys.userData.vel, delta);
    }

    function animateDamageTexts(delta) {
      for (let i = damageTexts.length-1; i>=0; i--) {
        const dt = damageTexts[i];
        const t = clock.getElapsedTime() - dt.start;
        if (t > dt.dur) {
          scene.remove(dt.mesh);
          damageTexts.splice(i,1);
          continue;
        }
        dt.mesh.position.y += delta * 0.2;
        dt.mesh.material.opacity = 1 - (t/dt.dur);
      }
    }

    function render() {
      const delta = clock.getDelta();
      // float cards & rotate arena
      cards.forEach(c => {
        const f = c.userData.float;
        const y = f.startY + Math.sin(clock.getElapsedTime()*f.speed + f.phase)*0.02;
        c.position.y = y;
        c.rotation.y += f.rotSpeed * delta;
      });
      battleArena.userData.particles.geometry.attributes.position.needsUpdate = true;
      // update ambient arena particles
      const arr = battleArena.userData.particles.geometry.attributes.position.array;
      battleArena.userData.particles.userData.velocities.forEach((v,i)=>{
        arr[3*i+1] += v.y;
        if (arr[3*i+1] > 0.8) arr[3*i+1] = 0;
      });
      battleArena.userData.particles.geometry.attributes.position.needsUpdate = true;

      if (rotationSpeed) battleArena.rotation.y += rotationSpeed * delta;

      animateParticles(playerAttackParticles, delta);
      animateParticles(enemyAttackParticles, delta);
      animateDamageTexts(delta);

      renderer.render(scene, camera);
    }

    function startARSession() {
      if (!navigator.xr) { alert('WebXR not supported'); return; }
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        if (!supported) { alert('AR not supported'); return; }
        navigator.xr.requestSession('immersive-ar', {
          optionalFeatures:['dom-overlay'], domOverlay:{root:document.body}
        }).then(onSessionStarted);
      });
    }

    function onSessionStarted(session) {
      xrSessionActive = true;
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      ['overlay','card-deck','game-ui','game-info','battle-log','tutorial']
        .forEach(id=>document.getElementById(id).style.display = id==='overlay' ? 'none' : '');

      document.getElementById('card-deck').style.display = 'flex';
      document.getElementById('game-ui').style.display = 'flex';
      document.getElementById('game-info').style.display = 'block';
      document.getElementById('battle-log').style.display = 'block';
      document.getElementById('tutorial').style.display = 'block';

      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      createFloatingDeck();
      renderer.setAnimationLoop(render);
    }
  </script>
</body>
</html>
